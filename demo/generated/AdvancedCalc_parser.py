# ==============================================================================
#  THIS FILE HAS BEEN AUTOMATICALLY GENERATED BY ACANTHOPYS
#  A Parsing Expression Grammar (PEG) Compiler-Compiler
# ==============================================================================
#
#  Generator: Acanthopys 0.1.0
#  Generated at: 2025-12-18 21:46:03
#
#  WARNING: DO NOT EDIT THIS FILE MANUALLY.
#  ANY CHANGES WILL BE OVERWRITTEN UPON REGENERATION.
#
# ==============================================================================

import re
from dataclasses import dataclass


@dataclass(frozen=True)
class Token:
    type: str
    value: str
    line: int = 0
    column: int = 0
    
    def __float__(self):
        return float(self.value)
        
    def __int__(self):
        return int(self.value)
        
    def __str__(self):
        return self.value

    def __repr__(self):
        return f"{self.value!r}"

class ParseError(Exception):
    """Exception raised when parsing fails."""
    def __init__(self, message: str, token=None, expected: list = None):
        super().__init__(message)
        self.message = message
        self.token = token
        self.expected = expected or []
        self.line = token.line if token else 0
        self.column = token.column if token else 0

class ErrorNode:
    """Represents an error in the parse tree for recovery mode."""
    def __init__(self, error_message: str = "", token=None, tokens_consumed: list = None, 
                 expected: list = None):
        self.error_message = error_message
        self.token = token
        self.tokens_consumed = tokens_consumed or []
        self.expected = expected or []
        self.line = token.line if token else 0
        self.column = token.column if token else 0
    
    def __repr__(self):
        return f'ErrorNode(message={self.error_message!r}, line={self.line}, col={self.column})'
    
    def __str__(self):
        return f'<error at {self.line}:{self.column}: {self.error_message}>'

class LeftRecursion:
    def __init__(self):
        self.detected = False
        self.seed = None

class Add:
    def __init__(self, *args, **kwargs):
        self.args = args
        for k, v in kwargs.items():
            setattr(self, k, v)
    def __repr__(self):
        params = []
        if self.args:
            params.extend([repr(a) for a in self.args])
        for k, v in self.__dict__.items():
            if k != 'args':
                params.append(repr(v))
        return f'Add({', '.join(params)})'

class Args:
    def __init__(self, *args, **kwargs):
        self.args = args
        for k, v in kwargs.items():
            setattr(self, k, v)
    def __repr__(self):
        params = []
        if self.args:
            params.extend([repr(a) for a in self.args])
        for k, v in self.__dict__.items():
            if k != 'args':
                params.append(repr(v))
        return f'Args({', '.join(params)})'

class Assign:
    def __init__(self, *args, **kwargs):
        self.args = args
        for k, v in kwargs.items():
            setattr(self, k, v)
    def __repr__(self):
        params = []
        if self.args:
            params.extend([repr(a) for a in self.args])
        for k, v in self.__dict__.items():
            if k != 'args':
                params.append(repr(v))
        return f'Assign({', '.join(params)})'

class Call:
    def __init__(self, *args, **kwargs):
        self.args = args
        for k, v in kwargs.items():
            setattr(self, k, v)
    def __repr__(self):
        params = []
        if self.args:
            params.extend([repr(a) for a in self.args])
        for k, v in self.__dict__.items():
            if k != 'args':
                params.append(repr(v))
        return f'Call({', '.join(params)})'

class Div:
    def __init__(self, *args, **kwargs):
        self.args = args
        for k, v in kwargs.items():
            setattr(self, k, v)
    def __repr__(self):
        params = []
        if self.args:
            params.extend([repr(a) for a in self.args])
        for k, v in self.__dict__.items():
            if k != 'args':
                params.append(repr(v))
        return f'Div({', '.join(params)})'

class Else:
    def __init__(self, *args, **kwargs):
        self.args = args
        for k, v in kwargs.items():
            setattr(self, k, v)
    def __repr__(self):
        params = []
        if self.args:
            params.extend([repr(a) for a in self.args])
        for k, v in self.__dict__.items():
            if k != 'args':
                params.append(repr(v))
        return f'Else({', '.join(params)})'

class Eq:
    def __init__(self, *args, **kwargs):
        self.args = args
        for k, v in kwargs.items():
            setattr(self, k, v)
    def __repr__(self):
        params = []
        if self.args:
            params.extend([repr(a) for a in self.args])
        for k, v in self.__dict__.items():
            if k != 'args':
                params.append(repr(v))
        return f'Eq({', '.join(params)})'

class ExprStmt:
    def __init__(self, *args, **kwargs):
        self.args = args
        for k, v in kwargs.items():
            setattr(self, k, v)
    def __repr__(self):
        params = []
        if self.args:
            params.extend([repr(a) for a in self.args])
        for k, v in self.__dict__.items():
            if k != 'args':
                params.append(repr(v))
        return f'ExprStmt({', '.join(params)})'

class Gt:
    def __init__(self, *args, **kwargs):
        self.args = args
        for k, v in kwargs.items():
            setattr(self, k, v)
    def __repr__(self):
        params = []
        if self.args:
            params.extend([repr(a) for a in self.args])
        for k, v in self.__dict__.items():
            if k != 'args':
                params.append(repr(v))
        return f'Gt({', '.join(params)})'

class IfStmt:
    def __init__(self, *args, **kwargs):
        self.args = args
        for k, v in kwargs.items():
            setattr(self, k, v)
    def __repr__(self):
        params = []
        if self.args:
            params.extend([repr(a) for a in self.args])
        for k, v in self.__dict__.items():
            if k != 'args':
                params.append(repr(v))
        return f'IfStmt({', '.join(params)})'

class Lt:
    def __init__(self, *args, **kwargs):
        self.args = args
        for k, v in kwargs.items():
            setattr(self, k, v)
    def __repr__(self):
        params = []
        if self.args:
            params.extend([repr(a) for a in self.args])
        for k, v in self.__dict__.items():
            if k != 'args':
                params.append(repr(v))
        return f'Lt({', '.join(params)})'

class Mul:
    def __init__(self, *args, **kwargs):
        self.args = args
        for k, v in kwargs.items():
            setattr(self, k, v)
    def __repr__(self):
        params = []
        if self.args:
            params.extend([repr(a) for a in self.args])
        for k, v in self.__dict__.items():
            if k != 'args':
                params.append(repr(v))
        return f'Mul({', '.join(params)})'

class Neq:
    def __init__(self, *args, **kwargs):
        self.args = args
        for k, v in kwargs.items():
            setattr(self, k, v)
    def __repr__(self):
        params = []
        if self.args:
            params.extend([repr(a) for a in self.args])
        for k, v in self.__dict__.items():
            if k != 'args':
                params.append(repr(v))
        return f'Neq({', '.join(params)})'

class Num:
    def __init__(self, *args, **kwargs):
        self.args = args
        for k, v in kwargs.items():
            setattr(self, k, v)
    def __repr__(self):
        params = []
        if self.args:
            params.extend([repr(a) for a in self.args])
        for k, v in self.__dict__.items():
            if k != 'args':
                params.append(repr(v))
        return f'Num({', '.join(params)})'

class Print:
    def __init__(self, *args, **kwargs):
        self.args = args
        for k, v in kwargs.items():
            setattr(self, k, v)
    def __repr__(self):
        params = []
        if self.args:
            params.extend([repr(a) for a in self.args])
        for k, v in self.__dict__.items():
            if k != 'args':
                params.append(repr(v))
        return f'Print({', '.join(params)})'

class Program:
    def __init__(self, *args, **kwargs):
        self.args = args
        for k, v in kwargs.items():
            setattr(self, k, v)
    def __repr__(self):
        params = []
        if self.args:
            params.extend([repr(a) for a in self.args])
        for k, v in self.__dict__.items():
            if k != 'args':
                params.append(repr(v))
        return f'Program({', '.join(params)})'

class Sub:
    def __init__(self, *args, **kwargs):
        self.args = args
        for k, v in kwargs.items():
            setattr(self, k, v)
    def __repr__(self):
        params = []
        if self.args:
            params.extend([repr(a) for a in self.args])
        for k, v in self.__dict__.items():
            if k != 'args':
                params.append(repr(v))
        return f'Sub({', '.join(params)})'

class Var:
    def __init__(self, *args, **kwargs):
        self.args = args
        for k, v in kwargs.items():
            setattr(self, k, v)
    def __repr__(self):
        params = []
        if self.args:
            params.extend([repr(a) for a in self.args])
        for k, v in self.__dict__.items():
            if k != 'args':
                params.append(repr(v))
        return f'Var({', '.join(params)})'

class val:
    def __init__(self, *args, **kwargs):
        self.args = args
        for k, v in kwargs.items():
            setattr(self, k, v)
    def __repr__(self):
        params = []
        if self.args:
            params.extend([repr(a) for a in self.args])
        for k, v in self.__dict__.items():
            if k != 'args':
                params.append(repr(v))
        return f'val({', '.join(params)})'

class Lexer:
    def __init__(self, text):
        self.text = text
        self.pos = 0
        self.tokens = []
        self.tokenize()

    def tokenize(self):
        # Regex patterns
        token_specs = [
            ('TOKEN_LET', r'let'),
            ('TOKEN_PRINT', r'print'),
            ('TOKEN_FUNC', r'func'),
            ('TOKEN_RETURN', r'return'),
            ('TOKEN_IF', r'if'),
            ('TOKEN_ELSE', r'else'),
            ('TOKEN_SEMI', r';'),
            ('TOKEN_COMMA', r','),
            ('TOKEN_EQEQ', r'=='),
            ('TOKEN_EQ', r'='),
            ('TOKEN_NEQ', r'!='),
            ('TOKEN_LT', r'<'),
            ('TOKEN_GT', r'>'),
            ('TOKEN_PLUS', r'\+'),
            ('TOKEN_MINUS', r'\-'),
            ('TOKEN_MUL', r'\*'),
            ('TOKEN_DIV', r'\/'),
            ('TOKEN_LPAREN', r'\('),
            ('TOKEN_RPAREN', r'\)'),
            ('TOKEN_LBRACE', r'\{'),
            ('TOKEN_RBRACE', r'\}'),
            ('TOKEN_NUMBER', r'\d+(\.\d+)?'),
            ('TOKEN_ID', r'[a-zA-Z_]\w*'),
            ('TOKEN_WS', r'\s+'),
            ('MISMATCH', r'.'),
        ]

        group_map = {'TOKEN_LET': 'LET', 'TOKEN_PRINT': 'PRINT', 'TOKEN_FUNC': 'FUNC', 'TOKEN_RETURN': 'RETURN', 'TOKEN_IF': 'IF', 'TOKEN_ELSE': 'ELSE', 'TOKEN_SEMI': 'SEMI', 'TOKEN_COMMA': 'COMMA', 'TOKEN_EQEQ': 'EQEQ', 'TOKEN_EQ': 'EQ', 'TOKEN_NEQ': 'NEQ', 'TOKEN_LT': 'LT', 'TOKEN_GT': 'GT', 'TOKEN_PLUS': 'PLUS', 'TOKEN_MINUS': 'MINUS', 'TOKEN_MUL': 'MUL', 'TOKEN_DIV': 'DIV', 'TOKEN_LPAREN': 'LPAREN', 'TOKEN_RPAREN': 'RPAREN', 'TOKEN_LBRACE': 'LBRACE', 'TOKEN_RBRACE': 'RBRACE', 'TOKEN_NUMBER': 'NUMBER', 'TOKEN_ID': 'ID', 'TOKEN_WS': 'WS'}

        # Compile regex
        tok_regex = '|'.join('(?P<%s>%s)' % pair for pair in token_specs)
        get_token = re.compile(tok_regex).match

        skipped_tokens = {'WS'}
        line_num = 1
        line_start = 0
        mo = get_token(self.text)
        while mo is not None:
            kind = mo.lastgroup
            value = mo.group(kind)
            if kind == 'MISMATCH':
                raise ParseError(f'Unexpected character {value!r} on line {line_num}')
            
            # Map back to token type
            token_type = group_map.get(kind, kind)
            
            if token_type in skipped_tokens:
                pass
            else:
                self.tokens.append(Token(token_type, value, line_num, mo.start() - line_start))
            
            # Update position
            pos = mo.end()
            mo = get_token(self.text, pos)
            if pos == len(self.text): break

class Parser:
    def __init__(self, tokens, enable_recovery=False):
        self.tokens = tokens
        self.pos = 0
        self.memo = {}
        self.enable_recovery = enable_recovery
        self.errors = []
        # Synchronization tokens for each rule (computed during generation)
        self.sync_tokens = {
            'Program': ['COMMA', 'ELSE', 'EOF', 'ID', 'IF', 'LET', 'LPAREN', 'NUMBER', 'PRINT'],
            'Statement': ['COMMA', 'ELSE', 'EOF', 'ID', 'IF', 'LET', 'LPAREN', 'NUMBER', 'PRINT', 'RBRACE'],
            'ElseClause': ['COMMA', 'ELSE', 'EOF', 'ID', 'IF', 'LET', 'LPAREN', 'NUMBER', 'PRINT', 'RBRACE'],
            'Expression': ['COMMA', 'ELSE', 'EOF', 'EQEQ', 'GT', 'ID', 'IF', 'LBRACE', 'LET', 'LPAREN', 'LT', 'NEQ', 'NUMBER', 'PRINT', 'RPAREN', 'SEMI'],
            'Additive': ['COMMA', 'ELSE', 'EOF', 'EQEQ', 'GT', 'ID', 'IF', 'LBRACE', 'LET', 'LPAREN', 'LT', 'MINUS', 'NEQ', 'NUMBER', 'PLUS', 'PRINT', 'RPAREN', 'SEMI'],
            'Multiplicative': ['COMMA', 'DIV', 'ELSE', 'EOF', 'EQEQ', 'GT', 'ID', 'IF', 'LBRACE', 'LET', 'LPAREN', 'LT', 'MINUS', 'MUL', 'NEQ', 'NUMBER', 'PLUS', 'PRINT', 'RPAREN', 'SEMI'],
            'Primary': ['COMMA', 'DIV', 'ELSE', 'EOF', 'EQEQ', 'GT', 'ID', 'IF', 'LBRACE', 'LET', 'LPAREN', 'LT', 'MINUS', 'MUL', 'NEQ', 'NUMBER', 'PLUS', 'PRINT', 'RPAREN', 'SEMI'],
            'ArgList': ['COMMA', 'ELSE', 'ID', 'IF', 'LET', 'LPAREN', 'NUMBER', 'PRINT', 'RPAREN'],
            'ArgRest': ['COMMA', 'ELSE', 'ID', 'IF', 'LET', 'LPAREN', 'NUMBER', 'PRINT', 'RPAREN'],
        }

    def current(self):
        if self.pos < len(self.tokens):
            return self.tokens[self.pos]
        return None

    def consume(self, type_name=None):
        token = self.current()
        if token and (type_name is None or token.type == type_name):
            self.pos += 1
            return token
        return None

    def expect(self, type_name):
        token = self.consume(type_name)
        if not token:
            found = self.current()
            msg = f'Expected {type_name}, found {found.type if found else "EOF"}'
            raise ParseError(msg, token=found, expected=[type_name])
        return token

    def skip_to_sync(self, rule_name, start_pos):
        """Skip tokens until finding a synchronization point."""
        if not self.enable_recovery:
            return
        
        sync_set = self.sync_tokens.get(rule_name, set())
        if not sync_set:
            return
        
        while self.pos < len(self.tokens):
            token = self.current()
            if token and token.type in sync_set:
                break
            self.pos += 1

    def add_error(self, error_msg, token=None, expected=None):
        """Record an error for later reporting."""
        if token is None:
            token = self.current()
        self.errors.append({
            'message': error_msg,
            'token': token,
            'expected': expected or [],
            'line': token.line if token else 0,
            'column': token.column if token else 0,
        })

    def get_errors(self):
        """Get all recorded errors."""
        return self.errors.copy()

    def _parse_Program_body(self):
        start_pos = self.pos
        # Option 0
        self.pos = start_pos
        try:
            # One or more Statement
            stmts = []
            stmts.append(self.parse_Statement())
            while True:
                _save = self.pos
                try:
                    _item = self.parse_Statement()
                    stmts.append(_item)
                    if self.enable_recovery and isinstance(_item, ErrorNode) and _save == self.pos:
                        if self.consume() is None:
                            break
                except ParseError:
                    self.pos = _save
                    break
            res = Program(stmts)
            return res
        except ParseError as e:
            pass
        # Option 1
        self.pos = start_pos
        try:
            expr = self.parse_Expression()
            res = Program([ExprStmt(expr)])
            return res
        except ParseError as e:
            pass
        # All alternatives failed for Program
        found = self.current()
        error = ParseError('No alternative matched for Program', token=found)
        
        if self.enable_recovery:
            if found is None:
                raise error
            self.add_error(error.message, token=found)
            self.skip_to_sync('Program', start_pos)
            # Return ErrorNode for recovery mode
            error_node = ErrorNode(
                error_message='No alternative matched for Program',
                tokens_consumed=self.tokens[start_pos:self.pos],
                token=found
            )
            return error_node
        
        raise error

    def parse_Program(self):
        key = ('Program', self.pos)
        
        if key in self.memo:
            res = self.memo[key]
            if isinstance(res, LeftRecursion):
                res.detected = True
                if res.seed is not None:
                    val, end_pos = res.seed
                    self.pos = end_pos
                    return val
                else:
                    raise ParseError('Left recursion detected')
            
            val, end_pos = res
            if isinstance(val, Exception):
                raise val
            self.pos = end_pos
            return val
        
        rec = LeftRecursion()
        self.memo[key] = rec
        start_pos = self.pos
        
        try:
            res = self._parse_Program_body()
        except ParseError as e:
            if not rec.detected:
                self.memo[key] = (e, start_pos)
                raise e
            res = None
        
        if rec.detected:
            if res is None:
                del self.memo[key]
                raise ParseError('Failed after recursion')
            
            rec.seed = (res, self.pos)
            last_end_pos = self.pos
            
            while True:
                self.pos = start_pos
                try:
                    new_res = self._parse_Program_body()
                    if self.pos > last_end_pos:
                        last_end_pos = self.pos
                        rec.seed = (new_res, self.pos)
                        res = new_res
                    else:
                        break
                except ParseError:
                    break
            
            self.pos = last_end_pos
            self.memo[key] = (res, self.pos)
            return res
        
        self.memo[key] = (res, self.pos)
        return res

    def _parse_Statement_body(self):
        start_pos = self.pos
        # Option 0
        self.pos = start_pos
        try:
            _ = self.expect('LET')
            name = self.expect('ID')
            _ = self.expect('EQ')
            val = self.parse_Expression()
            _ = self.expect('SEMI')
            res = Assign(name, val)
            return res
        except ParseError as e:
            pass
        # Option 1
        self.pos = start_pos
        try:
            _ = self.expect('PRINT')
            _ = self.expect('LPAREN')
            val = self.parse_Expression()
            _ = self.expect('RPAREN')
            _ = self.expect('SEMI')
            res = Print(val)
            return res
        except ParseError as e:
            pass
        # Option 2
        self.pos = start_pos
        try:
            _ = self.expect('IF')
            cond = self.parse_Expression()
            _ = self.expect('LBRACE')
            # One or more Statement
            then_block = []
            then_block.append(self.parse_Statement())
            while True:
                _save = self.pos
                try:
                    _item = self.parse_Statement()
                    then_block.append(_item)
                    if self.enable_recovery and isinstance(_item, ErrorNode) and _save == self.pos:
                        if self.consume() is None:
                            break
                except ParseError:
                    self.pos = _save
                    break
            _ = self.expect('RBRACE')
            # Optional ElseClause
            _save = self.pos
            try:
                else_block = self.parse_ElseClause()
            except ParseError:
                self.pos = _save
                else_block = None
            res = IfStmt(cond, then_block, else_block)
            return res
        except ParseError as e:
            pass
        # Option 3
        self.pos = start_pos
        try:
            val = self.parse_Expression()
            _ = self.expect('SEMI')
            res = ExprStmt(val)
            return res
        except ParseError as e:
            pass
        # All alternatives failed for Statement
        found = self.current()
        error = ParseError('No alternative matched for Statement', token=found)
        
        if self.enable_recovery:
            if found is None:
                raise error
            self.add_error(error.message, token=found)
            self.skip_to_sync('Statement', start_pos)
            # Return ErrorNode for recovery mode
            error_node = ErrorNode(
                error_message='No alternative matched for Statement',
                tokens_consumed=self.tokens[start_pos:self.pos],
                token=found
            )
            return error_node
        
        raise error

    def parse_Statement(self):
        key = ('Statement', self.pos)
        
        if key in self.memo:
            res = self.memo[key]
            if isinstance(res, LeftRecursion):
                res.detected = True
                if res.seed is not None:
                    val, end_pos = res.seed
                    self.pos = end_pos
                    return val
                else:
                    raise ParseError('Left recursion detected')
            
            val, end_pos = res
            if isinstance(val, Exception):
                raise val
            self.pos = end_pos
            return val
        
        rec = LeftRecursion()
        self.memo[key] = rec
        start_pos = self.pos
        
        try:
            res = self._parse_Statement_body()
        except ParseError as e:
            if not rec.detected:
                self.memo[key] = (e, start_pos)
                raise e
            res = None
        
        if rec.detected:
            if res is None:
                del self.memo[key]
                raise ParseError('Failed after recursion')
            
            rec.seed = (res, self.pos)
            last_end_pos = self.pos
            
            while True:
                self.pos = start_pos
                try:
                    new_res = self._parse_Statement_body()
                    if self.pos > last_end_pos:
                        last_end_pos = self.pos
                        rec.seed = (new_res, self.pos)
                        res = new_res
                    else:
                        break
                except ParseError:
                    break
            
            self.pos = last_end_pos
            self.memo[key] = (res, self.pos)
            return res
        
        self.memo[key] = (res, self.pos)
        return res

    def _parse_ElseClause_body(self):
        start_pos = self.pos
        # Option 0
        self.pos = start_pos
        try:
            _ = self.expect('ELSE')
            _ = self.expect('LBRACE')
            # One or more Statement
            stmts = []
            stmts.append(self.parse_Statement())
            while True:
                _save = self.pos
                try:
                    _item = self.parse_Statement()
                    stmts.append(_item)
                    if self.enable_recovery and isinstance(_item, ErrorNode) and _save == self.pos:
                        if self.consume() is None:
                            break
                except ParseError:
                    self.pos = _save
                    break
            _ = self.expect('RBRACE')
            res = Else(stmts)
            return res
        except ParseError as e:
            pass
        # All alternatives failed for ElseClause
        found = self.current()
        error = ParseError('No alternative matched for ElseClause', token=found)
        
        if self.enable_recovery:
            if found is None:
                raise error
            self.add_error(error.message, token=found)
            self.skip_to_sync('ElseClause', start_pos)
            # Return ErrorNode for recovery mode
            error_node = ErrorNode(
                error_message='No alternative matched for ElseClause',
                tokens_consumed=self.tokens[start_pos:self.pos],
                token=found
            )
            return error_node
        
        raise error

    def parse_ElseClause(self):
        key = ('ElseClause', self.pos)
        
        if key in self.memo:
            res = self.memo[key]
            if isinstance(res, LeftRecursion):
                res.detected = True
                if res.seed is not None:
                    val, end_pos = res.seed
                    self.pos = end_pos
                    return val
                else:
                    raise ParseError('Left recursion detected')
            
            val, end_pos = res
            if isinstance(val, Exception):
                raise val
            self.pos = end_pos
            return val
        
        rec = LeftRecursion()
        self.memo[key] = rec
        start_pos = self.pos
        
        try:
            res = self._parse_ElseClause_body()
        except ParseError as e:
            if not rec.detected:
                self.memo[key] = (e, start_pos)
                raise e
            res = None
        
        if rec.detected:
            if res is None:
                del self.memo[key]
                raise ParseError('Failed after recursion')
            
            rec.seed = (res, self.pos)
            last_end_pos = self.pos
            
            while True:
                self.pos = start_pos
                try:
                    new_res = self._parse_ElseClause_body()
                    if self.pos > last_end_pos:
                        last_end_pos = self.pos
                        rec.seed = (new_res, self.pos)
                        res = new_res
                    else:
                        break
                except ParseError:
                    break
            
            self.pos = last_end_pos
            self.memo[key] = (res, self.pos)
            return res
        
        self.memo[key] = (res, self.pos)
        return res

    def _parse_Expression_body(self):
        start_pos = self.pos
        # Option 0
        self.pos = start_pos
        try:
            left = self.parse_Expression()
            _ = self.expect('EQEQ')
            right = self.parse_Additive()
            res = Eq(left, right)
            return res
        except ParseError as e:
            pass
        # Option 1
        self.pos = start_pos
        try:
            left = self.parse_Expression()
            _ = self.expect('NEQ')
            right = self.parse_Additive()
            res = Neq(left, right)
            return res
        except ParseError as e:
            pass
        # Option 2
        self.pos = start_pos
        try:
            left = self.parse_Expression()
            _ = self.expect('LT')
            right = self.parse_Additive()
            res = Lt(left, right)
            return res
        except ParseError as e:
            pass
        # Option 3
        self.pos = start_pos
        try:
            left = self.parse_Expression()
            _ = self.expect('GT')
            right = self.parse_Additive()
            res = Gt(left, right)
            return res
        except ParseError as e:
            pass
        # Option 4
        self.pos = start_pos
        try:
            val = self.parse_Additive()
            res = val
            return res
        except ParseError as e:
            pass
        # All alternatives failed for Expression
        found = self.current()
        error = ParseError('No alternative matched for Expression', token=found)
        
        if self.enable_recovery:
            if found is None:
                raise error
            self.add_error(error.message, token=found)
            self.skip_to_sync('Expression', start_pos)
            # Return ErrorNode for recovery mode
            error_node = ErrorNode(
                error_message='No alternative matched for Expression',
                tokens_consumed=self.tokens[start_pos:self.pos],
                token=found
            )
            return error_node
        
        raise error

    def parse_Expression(self):
        key = ('Expression', self.pos)
        
        if key in self.memo:
            res = self.memo[key]
            if isinstance(res, LeftRecursion):
                res.detected = True
                if res.seed is not None:
                    val, end_pos = res.seed
                    self.pos = end_pos
                    return val
                else:
                    raise ParseError('Left recursion detected')
            
            val, end_pos = res
            if isinstance(val, Exception):
                raise val
            self.pos = end_pos
            return val
        
        rec = LeftRecursion()
        self.memo[key] = rec
        start_pos = self.pos
        
        try:
            res = self._parse_Expression_body()
        except ParseError as e:
            if not rec.detected:
                self.memo[key] = (e, start_pos)
                raise e
            res = None
        
        if rec.detected:
            if res is None:
                del self.memo[key]
                raise ParseError('Failed after recursion')
            
            rec.seed = (res, self.pos)
            last_end_pos = self.pos
            
            while True:
                self.pos = start_pos
                try:
                    new_res = self._parse_Expression_body()
                    if self.pos > last_end_pos:
                        last_end_pos = self.pos
                        rec.seed = (new_res, self.pos)
                        res = new_res
                    else:
                        break
                except ParseError:
                    break
            
            self.pos = last_end_pos
            self.memo[key] = (res, self.pos)
            return res
        
        self.memo[key] = (res, self.pos)
        return res

    def _parse_Additive_body(self):
        start_pos = self.pos
        # Option 0
        self.pos = start_pos
        try:
            left = self.parse_Additive()
            _ = self.expect('PLUS')
            right = self.parse_Multiplicative()
            res = Add(left, right)
            return res
        except ParseError as e:
            pass
        # Option 1
        self.pos = start_pos
        try:
            left = self.parse_Additive()
            _ = self.expect('MINUS')
            right = self.parse_Multiplicative()
            res = Sub(left, right)
            return res
        except ParseError as e:
            pass
        # Option 2
        self.pos = start_pos
        try:
            val = self.parse_Multiplicative()
            res = val
            return res
        except ParseError as e:
            pass
        # All alternatives failed for Additive
        found = self.current()
        error = ParseError('No alternative matched for Additive', token=found)
        
        if self.enable_recovery:
            if found is None:
                raise error
            self.add_error(error.message, token=found)
            self.skip_to_sync('Additive', start_pos)
            # Return ErrorNode for recovery mode
            error_node = ErrorNode(
                error_message='No alternative matched for Additive',
                tokens_consumed=self.tokens[start_pos:self.pos],
                token=found
            )
            return error_node
        
        raise error

    def parse_Additive(self):
        key = ('Additive', self.pos)
        
        if key in self.memo:
            res = self.memo[key]
            if isinstance(res, LeftRecursion):
                res.detected = True
                if res.seed is not None:
                    val, end_pos = res.seed
                    self.pos = end_pos
                    return val
                else:
                    raise ParseError('Left recursion detected')
            
            val, end_pos = res
            if isinstance(val, Exception):
                raise val
            self.pos = end_pos
            return val
        
        rec = LeftRecursion()
        self.memo[key] = rec
        start_pos = self.pos
        
        try:
            res = self._parse_Additive_body()
        except ParseError as e:
            if not rec.detected:
                self.memo[key] = (e, start_pos)
                raise e
            res = None
        
        if rec.detected:
            if res is None:
                del self.memo[key]
                raise ParseError('Failed after recursion')
            
            rec.seed = (res, self.pos)
            last_end_pos = self.pos
            
            while True:
                self.pos = start_pos
                try:
                    new_res = self._parse_Additive_body()
                    if self.pos > last_end_pos:
                        last_end_pos = self.pos
                        rec.seed = (new_res, self.pos)
                        res = new_res
                    else:
                        break
                except ParseError:
                    break
            
            self.pos = last_end_pos
            self.memo[key] = (res, self.pos)
            return res
        
        self.memo[key] = (res, self.pos)
        return res

    def _parse_Multiplicative_body(self):
        start_pos = self.pos
        # Option 0
        self.pos = start_pos
        try:
            left = self.parse_Multiplicative()
            _ = self.expect('MUL')
            right = self.parse_Primary()
            res = Mul(left, right)
            return res
        except ParseError as e:
            pass
        # Option 1
        self.pos = start_pos
        try:
            left = self.parse_Multiplicative()
            _ = self.expect('DIV')
            right = self.parse_Primary()
            res = Div(left, right)
            return res
        except ParseError as e:
            pass
        # Option 2
        self.pos = start_pos
        try:
            val = self.parse_Primary()
            res = val
            return res
        except ParseError as e:
            pass
        # All alternatives failed for Multiplicative
        found = self.current()
        error = ParseError('No alternative matched for Multiplicative', token=found)
        
        if self.enable_recovery:
            if found is None:
                raise error
            self.add_error(error.message, token=found)
            self.skip_to_sync('Multiplicative', start_pos)
            # Return ErrorNode for recovery mode
            error_node = ErrorNode(
                error_message='No alternative matched for Multiplicative',
                tokens_consumed=self.tokens[start_pos:self.pos],
                token=found
            )
            return error_node
        
        raise error

    def parse_Multiplicative(self):
        key = ('Multiplicative', self.pos)
        
        if key in self.memo:
            res = self.memo[key]
            if isinstance(res, LeftRecursion):
                res.detected = True
                if res.seed is not None:
                    val, end_pos = res.seed
                    self.pos = end_pos
                    return val
                else:
                    raise ParseError('Left recursion detected')
            
            val, end_pos = res
            if isinstance(val, Exception):
                raise val
            self.pos = end_pos
            return val
        
        rec = LeftRecursion()
        self.memo[key] = rec
        start_pos = self.pos
        
        try:
            res = self._parse_Multiplicative_body()
        except ParseError as e:
            if not rec.detected:
                self.memo[key] = (e, start_pos)
                raise e
            res = None
        
        if rec.detected:
            if res is None:
                del self.memo[key]
                raise ParseError('Failed after recursion')
            
            rec.seed = (res, self.pos)
            last_end_pos = self.pos
            
            while True:
                self.pos = start_pos
                try:
                    new_res = self._parse_Multiplicative_body()
                    if self.pos > last_end_pos:
                        last_end_pos = self.pos
                        rec.seed = (new_res, self.pos)
                        res = new_res
                    else:
                        break
                except ParseError:
                    break
            
            self.pos = last_end_pos
            self.memo[key] = (res, self.pos)
            return res
        
        self.memo[key] = (res, self.pos)
        return res

    def _parse_Primary_body(self):
        start_pos = self.pos
        # Option 0
        self.pos = start_pos
        try:
            _ = self.expect('LPAREN')
            val = self.parse_Expression()
            _ = self.expect('RPAREN')
            res = val
            return res
        except ParseError as e:
            pass
        # Option 1
        self.pos = start_pos
        try:
            name = self.expect('ID')
            _ = self.expect('LPAREN')
            # Optional ArgList
            _save = self.pos
            try:
                args = self.parse_ArgList()
            except ParseError:
                self.pos = _save
                args = None
            _ = self.expect('RPAREN')
            res = Call(name, args)
            return res
        except ParseError as e:
            pass
        # Option 2
        self.pos = start_pos
        try:
            n = self.expect('NUMBER')
            res = Num(float(n))
            return res
        except ParseError as e:
            pass
        # Option 3
        self.pos = start_pos
        try:
            i = self.expect('ID')
            res = Var(i)
            return res
        except ParseError as e:
            pass
        # All alternatives failed for Primary
        found = self.current()
        error = ParseError('No alternative matched for Primary', token=found)
        
        if self.enable_recovery:
            if found is None:
                raise error
            self.add_error(error.message, token=found)
            self.skip_to_sync('Primary', start_pos)
            # Return ErrorNode for recovery mode
            error_node = ErrorNode(
                error_message='No alternative matched for Primary',
                tokens_consumed=self.tokens[start_pos:self.pos],
                token=found
            )
            return error_node
        
        raise error

    def parse_Primary(self):
        key = ('Primary', self.pos)
        
        if key in self.memo:
            res = self.memo[key]
            if isinstance(res, LeftRecursion):
                res.detected = True
                if res.seed is not None:
                    val, end_pos = res.seed
                    self.pos = end_pos
                    return val
                else:
                    raise ParseError('Left recursion detected')
            
            val, end_pos = res
            if isinstance(val, Exception):
                raise val
            self.pos = end_pos
            return val
        
        rec = LeftRecursion()
        self.memo[key] = rec
        start_pos = self.pos
        
        try:
            res = self._parse_Primary_body()
        except ParseError as e:
            if not rec.detected:
                self.memo[key] = (e, start_pos)
                raise e
            res = None
        
        if rec.detected:
            if res is None:
                del self.memo[key]
                raise ParseError('Failed after recursion')
            
            rec.seed = (res, self.pos)
            last_end_pos = self.pos
            
            while True:
                self.pos = start_pos
                try:
                    new_res = self._parse_Primary_body()
                    if self.pos > last_end_pos:
                        last_end_pos = self.pos
                        rec.seed = (new_res, self.pos)
                        res = new_res
                    else:
                        break
                except ParseError:
                    break
            
            self.pos = last_end_pos
            self.memo[key] = (res, self.pos)
            return res
        
        self.memo[key] = (res, self.pos)
        return res

    def _parse_ArgList_body(self):
        start_pos = self.pos
        # Option 0
        self.pos = start_pos
        try:
            first = self.parse_Expression()
            # Zero or more ArgRest
            rest = []
            while True:
                _save = self.pos
                try:
                    _item = self.parse_ArgRest()
                    rest.append(_item)
                    if self.enable_recovery and isinstance(_item, ErrorNode) and _save == self.pos:
                        if self.consume() is None:
                            break
                except ParseError:
                    self.pos = _save
                    break
            res = Args(first, rest)
            return res
        except ParseError as e:
            pass
        # All alternatives failed for ArgList
        found = self.current()
        error = ParseError('No alternative matched for ArgList', token=found)
        
        if self.enable_recovery:
            if found is None:
                raise error
            self.add_error(error.message, token=found)
            self.skip_to_sync('ArgList', start_pos)
            # Return ErrorNode for recovery mode
            error_node = ErrorNode(
                error_message='No alternative matched for ArgList',
                tokens_consumed=self.tokens[start_pos:self.pos],
                token=found
            )
            return error_node
        
        raise error

    def parse_ArgList(self):
        key = ('ArgList', self.pos)
        
        if key in self.memo:
            res = self.memo[key]
            if isinstance(res, LeftRecursion):
                res.detected = True
                if res.seed is not None:
                    val, end_pos = res.seed
                    self.pos = end_pos
                    return val
                else:
                    raise ParseError('Left recursion detected')
            
            val, end_pos = res
            if isinstance(val, Exception):
                raise val
            self.pos = end_pos
            return val
        
        rec = LeftRecursion()
        self.memo[key] = rec
        start_pos = self.pos
        
        try:
            res = self._parse_ArgList_body()
        except ParseError as e:
            if not rec.detected:
                self.memo[key] = (e, start_pos)
                raise e
            res = None
        
        if rec.detected:
            if res is None:
                del self.memo[key]
                raise ParseError('Failed after recursion')
            
            rec.seed = (res, self.pos)
            last_end_pos = self.pos
            
            while True:
                self.pos = start_pos
                try:
                    new_res = self._parse_ArgList_body()
                    if self.pos > last_end_pos:
                        last_end_pos = self.pos
                        rec.seed = (new_res, self.pos)
                        res = new_res
                    else:
                        break
                except ParseError:
                    break
            
            self.pos = last_end_pos
            self.memo[key] = (res, self.pos)
            return res
        
        self.memo[key] = (res, self.pos)
        return res

    def _parse_ArgRest_body(self):
        start_pos = self.pos
        # Option 0
        self.pos = start_pos
        try:
            _ = self.expect('COMMA')
            val = self.parse_Expression()
            res = val(val=val)
            return res
        except ParseError as e:
            pass
        # All alternatives failed for ArgRest
        found = self.current()
        error = ParseError('No alternative matched for ArgRest', token=found)
        
        if self.enable_recovery:
            if found is None:
                raise error
            self.add_error(error.message, token=found)
            self.skip_to_sync('ArgRest', start_pos)
            # Return ErrorNode for recovery mode
            error_node = ErrorNode(
                error_message='No alternative matched for ArgRest',
                tokens_consumed=self.tokens[start_pos:self.pos],
                token=found
            )
            return error_node
        
        raise error

    def parse_ArgRest(self):
        key = ('ArgRest', self.pos)
        
        if key in self.memo:
            res = self.memo[key]
            if isinstance(res, LeftRecursion):
                res.detected = True
                if res.seed is not None:
                    val, end_pos = res.seed
                    self.pos = end_pos
                    return val
                else:
                    raise ParseError('Left recursion detected')
            
            val, end_pos = res
            if isinstance(val, Exception):
                raise val
            self.pos = end_pos
            return val
        
        rec = LeftRecursion()
        self.memo[key] = rec
        start_pos = self.pos
        
        try:
            res = self._parse_ArgRest_body()
        except ParseError as e:
            if not rec.detected:
                self.memo[key] = (e, start_pos)
                raise e
            res = None
        
        if rec.detected:
            if res is None:
                del self.memo[key]
                raise ParseError('Failed after recursion')
            
            rec.seed = (res, self.pos)
            last_end_pos = self.pos
            
            while True:
                self.pos = start_pos
                try:
                    new_res = self._parse_ArgRest_body()
                    if self.pos > last_end_pos:
                        last_end_pos = self.pos
                        rec.seed = (new_res, self.pos)
                        res = new_res
                    else:
                        break
                except ParseError:
                    break
            
            self.pos = last_end_pos
            self.memo[key] = (res, self.pos)
            return res
        
        self.memo[key] = (res, self.pos)
        return res
