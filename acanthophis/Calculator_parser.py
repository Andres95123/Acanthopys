# ==============================================================================
#  THIS FILE HAS BEEN AUTOMATICALLY GENERATED BY ACANTHOPYS
#  A Parsing Expression Grammar (PEG) Compiler-Compiler
# ==============================================================================
#
#  Generator: Acanthopys 0.1.0
#  Generated at: 2025-12-18 13:55:39
#
#  WARNING: DO NOT EDIT THIS FILE MANUALLY.
#  ANY CHANGES WILL BE OVERWRITTEN UPON REGENERATION.
#
# ==============================================================================

import re
from dataclasses import dataclass


@dataclass(frozen=True)
class Token:
    type: str
    value: str
    line: int = 0
    column: int = 0
    
    def __float__(self):
        return float(self.value)
        
    def __int__(self):
        return int(self.value)
        
    def __str__(self):
        return self.value

    def __repr__(self):
        return f"{self.value!r}"

class ParseError(Exception):
    pass

class AdditionNode:
    def __init__(self, *args, **kwargs):
        self.args = args
        for k, v in kwargs.items():
            setattr(self, k, v)
    def __repr__(self):
        params = []
        if self.args:
            params.extend([repr(a) for a in self.args])
        for k, v in self.__dict__.items():
            if k != 'args':
                params.append(repr(v))
        return f'AdditionNode({', '.join(params)})'

class AssignmentNode:
    def __init__(self, *args, **kwargs):
        self.args = args
        for k, v in kwargs.items():
            setattr(self, k, v)
    def __repr__(self):
        params = []
        if self.args:
            params.extend([repr(a) for a in self.args])
        for k, v in self.__dict__.items():
            if k != 'args':
                params.append(repr(v))
        return f'AssignmentNode({', '.join(params)})'

class ConditionalNode:
    def __init__(self, *args, **kwargs):
        self.args = args
        for k, v in kwargs.items():
            setattr(self, k, v)
    def __repr__(self):
        params = []
        if self.args:
            params.extend([repr(a) for a in self.args])
        for k, v in self.__dict__.items():
            if k != 'args':
                params.append(repr(v))
        return f'ConditionalNode({', '.join(params)})'

class DeclarationNode:
    def __init__(self, *args, **kwargs):
        self.args = args
        for k, v in kwargs.items():
            setattr(self, k, v)
    def __repr__(self):
        params = []
        if self.args:
            params.extend([repr(a) for a in self.args])
        for k, v in self.__dict__.items():
            if k != 'args':
                params.append(repr(v))
        return f'DeclarationNode({', '.join(params)})'

class DivisionNode:
    def __init__(self, *args, **kwargs):
        self.args = args
        for k, v in kwargs.items():
            setattr(self, k, v)
    def __repr__(self):
        params = []
        if self.args:
            params.extend([repr(a) for a in self.args])
        for k, v in self.__dict__.items():
            if k != 'args':
                params.append(repr(v))
        return f'DivisionNode({', '.join(params)})'

class EqualNode:
    def __init__(self, *args, **kwargs):
        self.args = args
        for k, v in kwargs.items():
            setattr(self, k, v)
    def __repr__(self):
        params = []
        if self.args:
            params.extend([repr(a) for a in self.args])
        for k, v in self.__dict__.items():
            if k != 'args':
                params.append(repr(v))
        return f'EqualNode({', '.join(params)})'

class ForLoopNode:
    def __init__(self, *args, **kwargs):
        self.args = args
        for k, v in kwargs.items():
            setattr(self, k, v)
    def __repr__(self):
        params = []
        if self.args:
            params.extend([repr(a) for a in self.args])
        for k, v in self.__dict__.items():
            if k != 'args':
                params.append(repr(v))
        return f'ForLoopNode({', '.join(params)})'

class GreaterThanNode:
    def __init__(self, *args, **kwargs):
        self.args = args
        for k, v in kwargs.items():
            setattr(self, k, v)
    def __repr__(self):
        params = []
        if self.args:
            params.extend([repr(a) for a in self.args])
        for k, v in self.__dict__.items():
            if k != 'args':
                params.append(repr(v))
        return f'GreaterThanNode({', '.join(params)})'

class GreaterThanOrEqualNode:
    def __init__(self, *args, **kwargs):
        self.args = args
        for k, v in kwargs.items():
            setattr(self, k, v)
    def __repr__(self):
        params = []
        if self.args:
            params.extend([repr(a) for a in self.args])
        for k, v in self.__dict__.items():
            if k != 'args':
                params.append(repr(v))
        return f'GreaterThanOrEqualNode({', '.join(params)})'

class IdentifierNode:
    def __init__(self, *args, **kwargs):
        self.args = args
        for k, v in kwargs.items():
            setattr(self, k, v)
    def __repr__(self):
        params = []
        if self.args:
            params.extend([repr(a) for a in self.args])
        for k, v in self.__dict__.items():
            if k != 'args':
                params.append(repr(v))
        return f'IdentifierNode({', '.join(params)})'

class LessThanNode:
    def __init__(self, *args, **kwargs):
        self.args = args
        for k, v in kwargs.items():
            setattr(self, k, v)
    def __repr__(self):
        params = []
        if self.args:
            params.extend([repr(a) for a in self.args])
        for k, v in self.__dict__.items():
            if k != 'args':
                params.append(repr(v))
        return f'LessThanNode({', '.join(params)})'

class LessThanOrEqualNode:
    def __init__(self, *args, **kwargs):
        self.args = args
        for k, v in kwargs.items():
            setattr(self, k, v)
    def __repr__(self):
        params = []
        if self.args:
            params.extend([repr(a) for a in self.args])
        for k, v in self.__dict__.items():
            if k != 'args':
                params.append(repr(v))
        return f'LessThanOrEqualNode({', '.join(params)})'

class LogicValueNode:
    def __init__(self, *args, **kwargs):
        self.args = args
        for k, v in kwargs.items():
            setattr(self, k, v)
    def __repr__(self):
        params = []
        if self.args:
            params.extend([repr(a) for a in self.args])
        for k, v in self.__dict__.items():
            if k != 'args':
                params.append(repr(v))
        return f'LogicValueNode({', '.join(params)})'

class ModulusNode:
    def __init__(self, *args, **kwargs):
        self.args = args
        for k, v in kwargs.items():
            setattr(self, k, v)
    def __repr__(self):
        params = []
        if self.args:
            params.extend([repr(a) for a in self.args])
        for k, v in self.__dict__.items():
            if k != 'args':
                params.append(repr(v))
        return f'ModulusNode({', '.join(params)})'

class MultiplicationNode:
    def __init__(self, *args, **kwargs):
        self.args = args
        for k, v in kwargs.items():
            setattr(self, k, v)
    def __repr__(self):
        params = []
        if self.args:
            params.extend([repr(a) for a in self.args])
        for k, v in self.__dict__.items():
            if k != 'args':
                params.append(repr(v))
        return f'MultiplicationNode({', '.join(params)})'

class NotEqualNode:
    def __init__(self, *args, **kwargs):
        self.args = args
        for k, v in kwargs.items():
            setattr(self, k, v)
    def __repr__(self):
        params = []
        if self.args:
            params.extend([repr(a) for a in self.args])
        for k, v in self.__dict__.items():
            if k != 'args':
                params.append(repr(v))
        return f'NotEqualNode({', '.join(params)})'

class NumberNode:
    def __init__(self, *args, **kwargs):
        self.args = args
        for k, v in kwargs.items():
            setattr(self, k, v)
    def __repr__(self):
        params = []
        if self.args:
            params.extend([repr(a) for a in self.args])
        for k, v in self.__dict__.items():
            if k != 'args':
                params.append(repr(v))
        return f'NumberNode({', '.join(params)})'

class RangeNode:
    def __init__(self, *args, **kwargs):
        self.args = args
        for k, v in kwargs.items():
            setattr(self, k, v)
    def __repr__(self):
        params = []
        if self.args:
            params.extend([repr(a) for a in self.args])
        for k, v in self.__dict__.items():
            if k != 'args':
                params.append(repr(v))
        return f'RangeNode({', '.join(params)})'

class SubtractionNode:
    def __init__(self, *args, **kwargs):
        self.args = args
        for k, v in kwargs.items():
            setattr(self, k, v)
    def __repr__(self):
        params = []
        if self.args:
            params.extend([repr(a) for a in self.args])
        for k, v in self.__dict__.items():
            if k != 'args':
                params.append(repr(v))
        return f'SubtractionNode({', '.join(params)})'

class Lexer:
    def __init__(self, text):
        self.text = text
        self.pos = 0
        self.tokens = []
        self.tokenize()

    def tokenize(self):
        # Regex patterns
        token_specs = [
            ('TOKEN_comment', r'//.*|/\*([^*]|\*+[^*/])*\*+/'),
            ('TOKEN_if_kw', r'\bif\b'),
            ('TOKEN_then_kw', r'\bthen\b'),
            ('TOKEN_elif_kw', r'\belif\b'),
            ('TOKEN_else_kw', r'\belse\b'),
            ('TOKEN_for_kw', r'\bfor\b'),
            ('TOKEN_in_kw', r'\bin\b'),
            ('TOKEN_do_kw', r'\bdo\b'),
            ('TOKEN_range_op', r'\.\.'),
            ('TOKEN_primitive_type', r'\b(int|float|bool|string)\b'),
            ('TOKEN_number', r'\d+(\.\d+)?'),
            ('TOKEN_logic_value', r'\b(true|false)\b'),
            ('TOKEN_gte', r'>='),
            ('TOKEN_lte', r'<='),
            ('TOKEN_eq', r'=='),
            ('TOKEN_neq', r'!='),
            ('TOKEN_gt', r'>'),
            ('TOKEN_lt', r'<'),
            ('TOKEN_assign', r'='),
            ('TOKEN_add', r'\+'),
            ('TOKEN_subtract', r'-'),
            ('TOKEN_multiply', r'\*'),
            ('TOKEN_divide', r'/'),
            ('TOKEN_modulus', r'%'),
            ('TOKEN_lparen', r'\('),
            ('TOKEN_rparen', r'\)'),
            ('TOKEN_colon', r':'),
            ('TOKEN_separator', r';'),
            ('TOKEN_identifier', r'[a-zA-Z_]\w*'),
            ('TOKEN_whitespace', r'\s+'),
            ('MISMATCH', r'.'),
        ]

        group_map = {'TOKEN_comment': 'comment', 'TOKEN_if_kw': 'if_kw', 'TOKEN_then_kw': 'then_kw', 'TOKEN_elif_kw': 'elif_kw', 'TOKEN_else_kw': 'else_kw', 'TOKEN_for_kw': 'for_kw', 'TOKEN_in_kw': 'in_kw', 'TOKEN_do_kw': 'do_kw', 'TOKEN_range_op': 'range_op', 'TOKEN_primitive_type': 'primitive_type', 'TOKEN_number': 'number', 'TOKEN_logic_value': 'logic_value', 'TOKEN_gte': 'gte', 'TOKEN_lte': 'lte', 'TOKEN_eq': 'eq', 'TOKEN_neq': 'neq', 'TOKEN_gt': 'gt', 'TOKEN_lt': 'lt', 'TOKEN_assign': 'assign', 'TOKEN_add': 'add', 'TOKEN_subtract': 'subtract', 'TOKEN_multiply': 'multiply', 'TOKEN_divide': 'divide', 'TOKEN_modulus': 'modulus', 'TOKEN_lparen': 'lparen', 'TOKEN_rparen': 'rparen', 'TOKEN_colon': 'colon', 'TOKEN_separator': 'separator', 'TOKEN_identifier': 'identifier', 'TOKEN_whitespace': 'whitespace'}

        # Compile regex
        tok_regex = '|'.join('(?P<%s>%s)' % pair for pair in token_specs)
        get_token = re.compile(tok_regex).match

        skipped_tokens = {'comment', 'whitespace'}
        line_num = 1
        line_start = 0
        mo = get_token(self.text)
        while mo is not None:
            kind = mo.lastgroup
            value = mo.group(kind)
            if kind == 'MISMATCH':
                raise ParseError(f'Unexpected character {value!r} on line {line_num}')
            
            # Map back to token type
            token_type = group_map.get(kind, kind)
            
            if token_type in skipped_tokens:
                pass
            else:
                self.tokens.append(Token(token_type, value, line_num, mo.start() - line_start))
            
            # Update position
            pos = mo.end()
            mo = get_token(self.text, pos)
            if pos == len(self.text): break

class Parser:
    def __init__(self, tokens):
        self.tokens = tokens
        self.pos = 0
        self.memo = {}

    def current(self):
        if self.pos < len(self.tokens):
            return self.tokens[self.pos]
        return None

    def consume(self, type_name=None):
        token = self.current()
        if token and (type_name is None or token.type == type_name):
            self.pos += 1
            return token
        return None

    def expect(self, type_name):
        token = self.consume(type_name)
        if not token:
            raise ParseError(f'Expected {type_name} at {self.pos}')
        return token

    def parse_Block(self):
        # Memoization check
        key = ('Block', self.pos)
        if key in self.memo:
            res, end_pos = self.memo[key]
            if isinstance(res, Exception):
                raise res
            self.pos = end_pos
            return res

        start_pos = self.pos
        # Option 0
        self.pos = start_pos
        try:
            stmt = self.parse_Declaration()
            res = stmt
            self.memo[key] = (res, self.pos)
            return res
        except ParseError:
            pass
        # Option 1
        self.pos = start_pos
        try:
            stmt = self.parse_Assignment()
            res = stmt
            self.memo[key] = (res, self.pos)
            return res
        except ParseError:
            pass
        # Option 2
        self.pos = start_pos
        try:
            stmt = self.parse_Conditional()
            res = stmt
            self.memo[key] = (res, self.pos)
            return res
        except ParseError:
            pass
        # Option 3
        self.pos = start_pos
        try:
            stmt = self.parse_ForLoop()
            res = stmt
            self.memo[key] = (res, self.pos)
            return res
        except ParseError:
            pass
        error = ParseError('No alternative matched for Block')
        self.memo[key] = (error, start_pos)
        raise error

    def parse_Declaration(self):
        # Memoization check
        key = ('Declaration', self.pos)
        if key in self.memo:
            res, end_pos = self.memo[key]
            if isinstance(res, Exception):
                raise res
            self.pos = end_pos
            return res

        start_pos = self.pos
        # Option 0
        self.pos = start_pos
        try:
            id = self.expect('identifier')
            _ = self.expect('colon')
            primitive = self.expect('primitive_type')
            res = DeclarationNode(id, primitive)
            self.memo[key] = (res, self.pos)
            return res
        except ParseError:
            pass
        error = ParseError('No alternative matched for Declaration')
        self.memo[key] = (error, start_pos)
        raise error

    def parse_Assignment(self):
        # Memoization check
        key = ('Assignment', self.pos)
        if key in self.memo:
            res, end_pos = self.memo[key]
            if isinstance(res, Exception):
                raise res
            self.pos = end_pos
            return res

        start_pos = self.pos
        # Option 0
        self.pos = start_pos
        try:
            id = self.expect('identifier')
            _ = self.expect('assign')
            val = self.parse_Operand()
            res = AssignmentNode(id, val)
            self.memo[key] = (res, self.pos)
            return res
        except ParseError:
            pass
        error = ParseError('No alternative matched for Assignment')
        self.memo[key] = (error, start_pos)
        raise error

    def parse_Operand(self):
        # Memoization check
        key = ('Operand', self.pos)
        if key in self.memo:
            res, end_pos = self.memo[key]
            if isinstance(res, Exception):
                raise res
            self.pos = end_pos
            return res

        start_pos = self.pos
        # Option 0
        self.pos = start_pos
        try:
            n = self.expect('number')
            res = NumberNode(float(n))
            self.memo[key] = (res, self.pos)
            return res
        except ParseError:
            pass
        # Option 1
        self.pos = start_pos
        try:
            lv = self.expect('logic_value')
            res = LogicValueNode(lv.value == 'true')
            self.memo[key] = (res, self.pos)
            return res
        except ParseError:
            pass
        # Option 2
        self.pos = start_pos
        try:
            id = self.expect('identifier')
            res = IdentifierNode(id)
            self.memo[key] = (res, self.pos)
            return res
        except ParseError:
            pass
        error = ParseError('No alternative matched for Operand')
        self.memo[key] = (error, start_pos)
        raise error

    def parse_Expression(self):
        # Memoization check
        key = ('Expression', self.pos)
        if key in self.memo:
            res, end_pos = self.memo[key]
            if isinstance(res, Exception):
                raise res
            self.pos = end_pos
            return res

        start_pos = self.pos
        # Option 0
        self.pos = start_pos
        try:
            term_val = self.parse_Comparison()
            res = term_val
            self.memo[key] = (res, self.pos)
            return res
        except ParseError:
            pass
        # Option 1
        self.pos = start_pos
        try:
            term_val = self.parse_Arithmetic()
            res = term_val
            self.memo[key] = (res, self.pos)
            return res
        except ParseError:
            pass
        error = ParseError('No alternative matched for Expression')
        self.memo[key] = (error, start_pos)
        raise error

    def parse_Arithmetic(self):
        # Memoization check
        key = ('Arithmetic', self.pos)
        if key in self.memo:
            res, end_pos = self.memo[key]
            if isinstance(res, Exception):
                raise res
            self.pos = end_pos
            return res

        start_pos = self.pos
        # Option 0
        self.pos = start_pos
        try:
            left = self.parse_Term()
            _ = self.expect('add')
            right = self.parse_Arithmetic()
            res = AdditionNode(left, right)
            self.memo[key] = (res, self.pos)
            return res
        except ParseError:
            pass
        # Option 1
        self.pos = start_pos
        try:
            left = self.parse_Term()
            _ = self.expect('subtract')
            right = self.parse_Arithmetic()
            res = SubtractionNode(left, right)
            self.memo[key] = (res, self.pos)
            return res
        except ParseError:
            pass
        # Option 2
        self.pos = start_pos
        try:
            term_val = self.parse_Term()
            res = term_val
            self.memo[key] = (res, self.pos)
            return res
        except ParseError:
            pass
        error = ParseError('No alternative matched for Arithmetic')
        self.memo[key] = (error, start_pos)
        raise error

    def parse_Term(self):
        # Memoization check
        key = ('Term', self.pos)
        if key in self.memo:
            res, end_pos = self.memo[key]
            if isinstance(res, Exception):
                raise res
            self.pos = end_pos
            return res

        start_pos = self.pos
        # Option 0
        self.pos = start_pos
        try:
            left = self.parse_Factor()
            _ = self.expect('multiply')
            right = self.parse_Term()
            res = MultiplicationNode(left, right)
            self.memo[key] = (res, self.pos)
            return res
        except ParseError:
            pass
        # Option 1
        self.pos = start_pos
        try:
            left = self.parse_Factor()
            _ = self.expect('divide')
            right = self.parse_Term()
            res = DivisionNode(left, right)
            self.memo[key] = (res, self.pos)
            return res
        except ParseError:
            pass
        # Option 2
        self.pos = start_pos
        try:
            left = self.parse_Factor()
            _ = self.expect('modulus')
            right = self.parse_Term()
            res = ModulusNode(left, right)
            self.memo[key] = (res, self.pos)
            return res
        except ParseError:
            pass
        # Option 3
        self.pos = start_pos
        try:
            term_val = self.parse_Factor()
            res = term_val
            self.memo[key] = (res, self.pos)
            return res
        except ParseError:
            pass
        error = ParseError('No alternative matched for Term')
        self.memo[key] = (error, start_pos)
        raise error

    def parse_Factor(self):
        # Memoization check
        key = ('Factor', self.pos)
        if key in self.memo:
            res, end_pos = self.memo[key]
            if isinstance(res, Exception):
                raise res
            self.pos = end_pos
            return res

        start_pos = self.pos
        # Option 0
        self.pos = start_pos
        try:
            _ = self.expect('lparen')
            term_val = self.parse_Arithmetic()
            _ = self.expect('rparen')
            res = term_val
            self.memo[key] = (res, self.pos)
            return res
        except ParseError:
            pass
        # Option 1
        self.pos = start_pos
        try:
            term_val = self.parse_Operand()
            res = term_val
            self.memo[key] = (res, self.pos)
            return res
        except ParseError:
            pass
        error = ParseError('No alternative matched for Factor')
        self.memo[key] = (error, start_pos)
        raise error

    def parse_Comparison(self):
        # Memoization check
        key = ('Comparison', self.pos)
        if key in self.memo:
            res, end_pos = self.memo[key]
            if isinstance(res, Exception):
                raise res
            self.pos = end_pos
            return res

        start_pos = self.pos
        # Option 0
        self.pos = start_pos
        try:
            left = self.parse_Arithmetic()
            _ = self.expect('gte')
            right = self.parse_Arithmetic()
            res = GreaterThanOrEqualNode(left, right)
            self.memo[key] = (res, self.pos)
            return res
        except ParseError:
            pass
        # Option 1
        self.pos = start_pos
        try:
            left = self.parse_Arithmetic()
            _ = self.expect('lte')
            right = self.parse_Arithmetic()
            res = LessThanOrEqualNode(left, right)
            self.memo[key] = (res, self.pos)
            return res
        except ParseError:
            pass
        # Option 2
        self.pos = start_pos
        try:
            left = self.parse_Arithmetic()
            _ = self.expect('eq')
            right = self.parse_Arithmetic()
            res = EqualNode(left, right)
            self.memo[key] = (res, self.pos)
            return res
        except ParseError:
            pass
        # Option 3
        self.pos = start_pos
        try:
            left = self.parse_Arithmetic()
            _ = self.expect('neq')
            right = self.parse_Arithmetic()
            res = NotEqualNode(left, right)
            self.memo[key] = (res, self.pos)
            return res
        except ParseError:
            pass
        # Option 4
        self.pos = start_pos
        try:
            left = self.parse_Arithmetic()
            _ = self.expect('gt')
            right = self.parse_Arithmetic()
            res = GreaterThanNode(left, right)
            self.memo[key] = (res, self.pos)
            return res
        except ParseError:
            pass
        # Option 5
        self.pos = start_pos
        try:
            left = self.parse_Arithmetic()
            _ = self.expect('lt')
            right = self.parse_Arithmetic()
            res = LessThanNode(left, right)
            self.memo[key] = (res, self.pos)
            return res
        except ParseError:
            pass
        error = ParseError('No alternative matched for Comparison')
        self.memo[key] = (error, start_pos)
        raise error

    def parse_Conditional(self):
        # Memoization check
        key = ('Conditional', self.pos)
        if key in self.memo:
            res, end_pos = self.memo[key]
            if isinstance(res, Exception):
                raise res
            self.pos = end_pos
            return res

        start_pos = self.pos
        # Option 0
        self.pos = start_pos
        try:
            _ = self.expect('if_kw')
            cond = self.parse_Expression()
            _ = self.expect('then_kw')
            thenBranch = self.parse_Block()
            _ = self.expect('elif_kw')
            elifCond = self.parse_Expression()
            _ = self.expect('then_kw')
            elifBranch = self.parse_Block()
            _ = self.expect('else_kw')
            elseBranch = self.parse_Block()
            res = ConditionalNode(cond, thenBranch, ConditionalNode(elifCond, elifBranch, elseBranch))
            self.memo[key] = (res, self.pos)
            return res
        except ParseError:
            pass
        # Option 1
        self.pos = start_pos
        try:
            _ = self.expect('if_kw')
            cond = self.parse_Expression()
            _ = self.expect('then_kw')
            thenBranch = self.parse_Block()
            _ = self.expect('else_kw')
            elseBranch = self.parse_Block()
            res = ConditionalNode(cond, thenBranch, elseBranch)
            self.memo[key] = (res, self.pos)
            return res
        except ParseError:
            pass
        # Option 2
        self.pos = start_pos
        try:
            _ = self.expect('if_kw')
            cond = self.parse_Expression()
            _ = self.expect('then_kw')
            thenBranch = self.parse_Block()
            res = ConditionalNode(cond, thenBranch, None)
            self.memo[key] = (res, self.pos)
            return res
        except ParseError:
            pass
        error = ParseError('No alternative matched for Conditional')
        self.memo[key] = (error, start_pos)
        raise error

    def parse_Range(self):
        # Memoization check
        key = ('Range', self.pos)
        if key in self.memo:
            res, end_pos = self.memo[key]
            if isinstance(res, Exception):
                raise res
            self.pos = end_pos
            return res

        start_pos = self.pos
        # Option 0
        self.pos = start_pos
        try:
            init = self.parse_Arithmetic()
            _ = self.expect('range_op')
            final = self.parse_Arithmetic()
            res = RangeNode(init, final)
            self.memo[key] = (res, self.pos)
            return res
        except ParseError:
            pass
        error = ParseError('No alternative matched for Range')
        self.memo[key] = (error, start_pos)
        raise error

    def parse_ForLoop(self):
        # Memoization check
        key = ('ForLoop', self.pos)
        if key in self.memo:
            res, end_pos = self.memo[key]
            if isinstance(res, Exception):
                raise res
            self.pos = end_pos
            return res

        start_pos = self.pos
        # Option 0
        self.pos = start_pos
        try:
            _ = self.expect('for_kw')
            var = self.expect('identifier')
            _ = self.expect('in_kw')
            range = self.parse_Range()
            _ = self.expect('do_kw')
            body = self.parse_Block()
            res = ForLoopNode(var, range, body)
            self.memo[key] = (res, self.pos)
            return res
        except ParseError:
            pass
        error = ParseError('No alternative matched for ForLoop')
        self.memo[key] = (error, start_pos)
        raise error
